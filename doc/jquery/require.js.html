<!doctype html><html><head><title>Doc</title><body><dl><dd>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a0">function mixin(target, source, force) {</a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a1">function makeError(id, msg, err) {</a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a2">function configurePackageDir(pkgs, currentPackages, dir) {</a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a3">function jQueryHoldReady($, shouldHold) {</a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a4">function newContext(contextName) {</a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a5">function trimDots(ary) {</a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a6">function normalize(name, baseName) {</a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a7">function makeModuleMap(name, parentModuleMap) {</a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a8">function isPriorityDone() {</a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a9">function makeRequire(relModuleMap, enableBuildCallback) {</a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a10">function makeArgCallback(manager, i) {</a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a11">function addWait(manager) {</a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a12">function managerAdd(cb) {</a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a13">function callDefMain(args) {</a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a14">jQueryCheck </a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a15">function checkLoaded() {</a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a16">resume </a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a17">configure</a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a18">takeGlobalQueue</a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a19">completeLoad</a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a20">toUrl</a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a21">nameToUrl</a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a22">req </a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a23">req.config </a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a24">if (!require) {</a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a25">req.toUrl </a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a26">req.onError </a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a27">req.load </a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a28">define </a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a29">req.exec </a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a30">req.execCb </a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a31">req.addScriptToDom </a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a32">req.onScriptLoad </a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a33">req.attach </a></dd><dd>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#a34">req.resourcesReady </a></dd></dl><pre id="a0">function mixin(target, source, force) {</pre><p>Simple function to mix in properties from source into target, but only if target does not already have a property of the same name. This is not robust in IE for transferring methods that match Object.prototype names, but the uses of mixin here seem unlikely to trigger a problem related to that. </p><br/><pre id="a1">function makeError(id, msg, err) {</pre><p>Constructs an error with a pointer to an URL with more information. <br/><b>param {String}</b> id the error ID that maps to an ID on a web page. <br/><b>param {String}</b> message human readable error. <br/><b>param {Error}</b> [err] the original error, if there is one.  <br/><b>returns {Error}</b> </p><br/><pre id="a2">function configurePackageDir(pkgs, currentPackages, dir) {</pre><p>Used to set up package paths from a packagePaths or packages config object. <br/><b>param {Object}</b> pkgs the object to store the new package config <br/><b>param {Array}</b> currentPackages an array of packages to configure <br/><b>param {String}</b> [dir] a prefix dir to use. </p><br/><pre id="a3">function jQueryHoldReady($, shouldHold) {</pre><p>jQuery 1.4.3-1.5.x use a readyWait/ready() pairing to hold DOM ready callbacks, but jQuery 1.6 supports a holdReady() API instead. At some point remove the readyWait/ready() support and just stick with using holdReady. </p><br/><pre id="a4">function newContext(contextName) {</pre><p>Creates a new context for use in require and define calls. Handle most of the heavy lifting. Do not want to use an object with prototype here to avoid using "this" in require, in case it needs to be used in more super secure envs that do not want this. Also there should not be that many contexts in the page. Usually just one for the default context, but could be extra for multiversion cases or if a package needs a special context for a dependency that conflicts with the standard context. </p><br/><pre id="a5">function trimDots(ary) {</pre><p>Trims the . and .. from an array of path segments. It will keep a leading path segment if a .. will become the first path segment, to help with module name lookups, which act like paths, but can be remapped. But the end result, all paths that use this function should look normalized. NOTE: this method MODIFIES the input array. <br/><b>param {Array}</b> ary the array of path segments. </p><br/><pre id="a6">function normalize(name, baseName) {</pre><p>Given a relative module name, like ./something, normalize it to a real name that can be mapped to a path. <br/><b>param {String}</b> name the relative name <br/><b>param {String}</b> baseName a real name that the name arg is relative to. <br/><b>returns {String}</b> normalized name </p><br/><pre id="a7">function makeModuleMap(name, parentModuleMap) {</pre><p>Creates a module mapping that includes plugin prefix, module name, and path. If parentModuleMap is provided it will also normalize the name via require.normalize()  <br/><b>param {String}</b> name the module name <br/><b>param {String}</b> [parentModuleMap] parent module map for the module name, used to resolve relative names.  <br/><b>returns {Object}</b> </p><br/><pre id="a8">function isPriorityDone() {</pre><p>Determine if priority loading is done. If so clear the priorityWait </p><br/><pre id="a9">function makeRequire(relModuleMap, enableBuildCallback) {</pre><p>Helper function that creates a require function object to give to modules that ask for it as a dependency. It needs to be specific per module because of the implication of path mappings that may need to be relative to the module name. </p><br/><pre id="a10">function makeArgCallback(manager, i) {</pre><p>Helper that creates a callack function that is called when a dependency is ready, and sets the i-th dependency for the manager as the value passed to the callback generated by this function. </p><br/><pre id="a11">function addWait(manager) {</pre><p>Adds the manager to the waiting queue. Only fully resolved items should be in the waiting queue. </p><br/><pre id="a12">function managerAdd(cb) {</pre><p>Function added to every manager object. Created out here to avoid new function creation for each manager instance. </p><br/><pre id="a13">function callDefMain(args) {</pre><p>Convenience method to call main for a define call that was put on hold in the defQueue. </p><br/><pre id="a14">jQueryCheck = function (jqCandidate) {</pre><p>jQuery 1.4.3+ supports ways to hold off calling calling jQuery ready callbacks until all scripts are loaded. Be sure to track it if the capability exists.. Also, since jQuery 1.4.3 does not register as a module, need to do some global inference checking. Even if it does register as a module, not guaranteed to be the precise name of the global. If a jQuery is tracked for this context, then go ahead and register it as a module too, if not already in process. </p><br/><pre id="a15">function checkLoaded() {</pre><p>Checks if all modules for a context are loaded, and if so, evaluates the new ones in right dependency order.  <br/><b>private</b> </p><br/><pre id="a16">resume = function () {</pre><p>Resumes tracing of dependencies and then checks if everything is loaded. </p><br/><pre id="a17">configure: function (cfg) {</pre><p>Set a configuration for the context. <br/><b>param {Object}</b> cfg config object to integrate. </p><br/><pre id="a18">takeGlobalQueue: function () {</pre><p>Internal method to transfer globalQueue items to this context's defQueue. </p><br/><pre id="a19">completeLoad: function (moduleName) {</pre><p>Internal method used by environment adapters to complete a load event. A load event could be a script load or just a load pass from a synchronous load call. <br/><b>param {String}</b> moduleName the name of the module to potentially complete. </p><br/><pre id="a20">toUrl: function (moduleNamePlusExt, relModuleMap) {</pre><p>Converts a module name + .extension into an URL path. *Requires* the use of a module name. It does not support using plain URLs like nameToUrl. </p><br/><pre id="a21">nameToUrl: function (moduleName, ext, relModuleMap) {</pre><p>Converts a module name to a file path. Supports cases where moduleName may actually be just an URL. </p><br/><pre id="a22">req = requirejs = function (deps, callback) {</pre><p>Main entry point.  If the only argument to require is a string, then the module that is represented by that string is fetched for the appropriate context.  If the first argument is an array, then it will be treated as an array of dependency string names to fetch. An optional function callback can be specified to execute when all of those dependencies are available.  Make a local req variable to help Caja compliance (it assumes things on a require that are not standardized), and to give a short name for minification/local scope use. </p><br/><pre id="a23">req.config = function (config) {</pre><p>Support require.config() to make it easier to cooperate with other AMD loaders on globally agreed names. </p><br/><pre id="a24">if (!require) {</pre><p>Export require as a global, but only if it does not already exist. </p><br/><pre id="a25">req.toUrl = function (moduleNamePlusExt) {</pre><p>Global require.toUrl(), to match global require, mostly useful for debugging/work in the global space. </p><br/><pre id="a26">req.onError = function (err) {</pre><p>Any errors that require explicitly generates will be passed to this function. Intercept/override it if you want custom error handling. <br/><b>param {Error}</b> err the error object. </p><br/><pre id="a27">req.load = function (context, moduleName, url) {</pre><p>Does the request to load a module for the browser case. Make this a separate function to allow other environments to override it.  <br/><b>param {Object}</b> context the require context to find state. <br/><b>param {String}</b> moduleName the name of the module. <br/><b>param {Object}</b> url the URL to the module. </p><br/><pre id="a28">define = function (name, deps, callback) {</pre><p>The function that handles definitions of modules. Differs from require() in that a string for the module should be the first argument, and the function to execute after dependencies are loaded should return a value to define the module corresponding to the first argument's name. </p><br/><pre id="a29">req.exec = function (text) {</pre><p>Executes the text. Normally just uses eval, but can be modified to use a more environment specific call. <br/><b>param {String}</b> text the text to execute/evaluate. </p><br/><pre id="a30">req.execCb = function (name, callback, args, exports) {</pre><p>Executes a module callack function. Broken out as a separate function solely to allow the build system to sequence the files in the built layer in the right sequence.  <br/><b>private</b> </p><br/><pre id="a31">req.addScriptToDom = function (node) {</pre><p>Adds a node to the DOM. Public function since used by the order plugin. This method should not normally be called by outside code. </p><br/><pre id="a32">req.onScriptLoad = function (evt) {</pre><p>callback for script loads, used to check status of loading.  <br/><b>param {Event}</b> evt the event from the browser for the script that was loaded.  <br/><b>private</b> </p><br/><pre id="a33">req.attach = function (url, context, moduleName, callback, type, fetchOnlyFunction) {</pre><p>Attaches the script represented by the URL to the current environment. Right now only supports browser loading, but can be redefined in other environments to do the right thing. <br/><b>param {String}</b> url the url of the script to attach. <br/><b>param {Object}</b> context the context that wants the script. <br/><b>param {moduleName}</b> the name of the module that is associated with the script. <br/><b>param {Function}</b> [callback] optional callback, defaults to require.onScriptLoad <br/><b>param {String}</b> [type] optional type, defaults to text/javascript <br/><b>param {Function}</b> [fetchOnlyFunction] optional function to indicate the script node should be set up to fetch the script but do not attach it to the DOM so that it can later be attached to execute it. This is a way for the order plugin to support ordered loading in IE. Once the script is fetched, but not executed, the fetchOnlyFunction will be called. </p><br/><pre id="a34">req.resourcesReady = function (isReady) {</pre><p>Internal function that is triggered whenever all scripts/resources have been loaded by the loader. Can be overridden by other, for instance the domReady plugin, which wants to know when all resources are loaded. </p><br/></body></html>